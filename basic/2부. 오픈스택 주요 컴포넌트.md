# 2부. 오픈스택 주요 컴포넌트

- OpenStack은 클라우드 인프라를 구축하고 관리하기 위한 오픈 소스 플랫폼
- 다양한 컴포넌트(서비스)를 통해 컴퓨팅, 네트워킹, 스토리지, 아이덴티티 및 이미지 관리 등의 기능을 제공
- 플러그 앤 플레이 방식으로 설계되어 있어, 사용자가 필요에 따라 선택적으로 구성하고 확장 가능
- 또한 모듈식 구조로 각각의 서비스가 독립적으로 작동하면서 서로 통합 가능

![openstack-map](../img/openstack-map.png)

- 핵심 컴포넌트
  - Nova(Compute)
    - OpenStack의 컴퓨팅 엔진으로 가상 머신의 생명 주기 관리 담당
    - 사용자가 클라우드 내에서 VM을 생성, 스케줄링, 삭제하는 기능을 제공
  - Neutron(Networking)
    - 클라우드 내 네트워킹 기능을 관리
    - 가상 네트워크, 서브넷, 라우터 등을 설정하고 관리
  - Cinder(Block Storage)
    - 블록 스토리지 서비스를 제공하여 VM에 영구적인 스토리지를 붙일 수 있게 함
    - 데이터베이스, 파일 시스템 등을 위한 스토리지 볼륨을 관리
  - Swift(Object Storage)
    - 객체 스토리지 서비스로, 대규모의 비정형 데이터를 저장할 수 있음
    - 정적 파일, 미디어 파일 등으로 저장하고, HTTP로 접근할 수 있게 함
  - Glance(Image Service)
    - 가상 머신 이미지를 관리하는 서비스
    - VM 이미지의 등록, 저장, 검색 및 기능을 제공
  - Keystone(Identity Service)
    - OpenStack 내의 모든 인증 및 권한 부여 작업을 담당
    - 사용자와 서비스 간의 인증을 관리
- 추가 컴포넌트
  - Horizon
    - OpenStack의 대시보드로, 웹 기반의 사용자 인터페이스를 제공하여 OpenStack 서비스 관리를 지원
  - Heat
    - 오케스트레이션 서비스
    - 템플릿을 사용하여 애플리케이션 스택의 자원을 자동으로 생성하고 관리
  - Ceilometer
    - 텔레메트리 서비스(알림 등의 서비스)
    - 클라우드 사용에 대한 메트릭 수집, 모니터링 및 빌링을 위한 데이터를 제공
  - Trove
    - 데이터베이스 서비스
    - 관계형 및 비관계형 데이터베이스 인스턴스를 관리 기능 지원

![openstack-ecosystem](../img/diagram_openstack_ecosystem.png)

---

## 1. 인증 서비스(Keystone)

- 오픈스택의 핵심 인증 서비스로 사용자 인증 및 서비스 간 권한 부여를 담당

### 1.1 인증과 권한 부여

#### 인증(Authentication)

- 역할
  - Keystone의 인증 과정은 사용자나 서비스가 시스템에 접근을 요청할 때, 그들의 신원을 확인하는 과정
  - 사용자가 올바른 신원 증명(일반적으론 ID와 PW)을 제공하면, Keystone은 이를 검증하고 요청에 대한 승인을 결정
- 토큰 기반 인증
  - Keystone은 성공적인 인증 후에 토큰 발급
  - 발급된 토큰은 사용자가 다른 오픈스택 서비스에 대한 요청을 할 때 사용하며, 사용자의 신원과 권한 수준을 나타냄
  - 토큰은 유효 기간이 있으며 기간이 지나면 재인증 필요

#### 권한 부여(Authorization)

- 역할
  - 인증 과정을 끝낸 사용자나 서비스에 대해, Keystone은 해당 사용자가 수행할 수 있는 작업의 범위를 결정
  - 사용자에게 할당된 역할과 정책에 기반하여 이루어짐
- 역할 기반 접근 제어(RBAC)
  - Keystone은 역할 기반 접근 제어 모델을 사용하여 권한을 관리
  - 사용자는 하나 이상의 역할을 가질 수 있으며, 각 역할은 특정 리소스에 대한 접근 권한을 정의
  - 예) `admin` 역할을 가진 사용자는 시스템의 모든 리소스를 관리할 수 있지만, `member` 역할을 가진 사용자는 제한된 리소스에만 접근 가능
- 정책 관리
  - Keystone은 정책 파일을 통해 세밀한 권한 부여 규칙을 정의할 수 있음
  - 파일 형식은 JSON 또는 YAML 형식으로 작성
  - 서비스별로 다양한 작업에 대한 접근 권하을 구체적으로 설정할 수 있음

### 1.2 Keystone의 아키텍처

#### 주요 구성 요소

1. Keystone 서버
- RESTful API 인터페이스를 제공
- 인증 요청을 처리하고, 유효한 요청에 대해 토큰을 발급
- 사용자, 역할, 프로젝트 등의 관리 기능을 수행

2. 토큰 관리 서비스
- 인증이 성공적으로 이루어졌으면, Keystone은 접근 토큰을 발급
- 발급된 토큰이 사용자가 오픈스택의 다른 서비스에 접근할 때 사용되며, 사용자의 권한을 나타냄
- 토큰은 일정 시간이 지나면 만료되며, 이때는 새로운 토큰을 요청해야 함

3. 서비스 카탈로그
- Keystone은 오픈스택 클라우드 내의 모든 서비스와 그 API 엔드포인트에 대한 정보를 관리하는 서비스 카탈로그를 제공
- 사용자나 서비스가 필요한 리소스를 찾을 때 이 카탈로그를 조회

4. 정책 관리
- Keystone은 Json 또는 YAML 형식의 정책 파일을 통해 권한 부여 정책을 관리
- 여기서 정책은 특정 작업을 수행할 수 있는 사용자나 역할을 정의함
- 정책 관리를 통해 리소스에 대한 접근을 세밀하게 제어할 수 있음

5. 백엔드 스토리지
- 사용자 정보, 역할, 토큰 등 Keystone에서 관리하는 데이터는 백엔드 스토리지에 저장
- Keystone은 SQL 데이터베이스(예: MySQL, PostgreSQL)를 기본 스토리지로 사용하며, LDAP 디렉토리 서비스와의 통합도 지원


#### 아키텍처 특징

- 모듈성
  - Keystone의 아키텍처는 모듈식으로 설계되어 있어, 다양한 백엔드 스토리지와 인증 메커니즘을 지원
  - 이를 통해 확장성과 유연성이 향상
- 확장성
  - 대규모 클라우드 환경에서도 Keystone은 높은 확장성을 제공
  - 효율적인 토큰 관리와 분산된 아키텍처를 통해 다수의 인증 요청 처리 가능
- 보안
  - SSL/TLS를 통한 데이터 암호화, 정기적인 토큰 만료, 정책 기반의 접근 제어 등을 통해 클라우드 인프라스트럭처의 보안을 강화

  
### 1.3 사용자 및 서비스 관리

#### 사용자 관리

1. 사용자 생성
- Keystone에서는 관리자가 새로운 사용자 계정을 생성할 수 있음
- 각 사용자는 고유한 신원 정보(예. ID, PW 등)와 연결

2. 역할 할당
- 사용자에게 하나 이상의 역할을 할당하고, 그들이 수행할 수 있는 작업의 범위를 정의
- 역할은 특정 권한을 나타냄

3. 프로젝트 및 도메인
- 사용자는 하나 이상의 프로젝트 또는 테넌트에 속할 수 있음
- 프로젝트는 리소스의 그룹을 격리하는 단위이며, 도메인은 프로젝트와 사용자를 포함하는 더 큰 관리 단위
- 이를 통해 리소스 접근을 조직적으로 관리할 수 있음

#### 서비스 관리

1. 서비스 등록
- 오픈스택에서 제공하는 다양한 서비스는 Keystone 서비스 카탈로그에 등록되어야 함
- 서비스 등록 과정에서는 서비스의 이름, 타입, API 엔드포인트 등의 정보가 지정

2. 엔드포인트 관리
- 각 서비스에 대한 API 엔드포인트는 Keystone을 통해 관리
- 엔드포인트는 일반적으로 퍼블릭(외부 접근 가능), 인터널(내부 네트워크 접근), 어드민(관리 작업용) 세 가지 유형으로 구분

3. 서비스 카탈로그
- 클라우드 환경 내에서 사용 가능한 모든 서비스와 그 엔드포인트를 목록화 함
- 사용자와 다른 서비스는 서비스 카탈로그를 조회하여 필요한 서비스의 API에 접근 가능

#### 정책 관리

- 정책 파일은 JSON 또는 YAML 형식의 정책 파일을 통해 서비스별 접근 정책을 정의
- 정책 파일은 특정 작업을 수행할 수 있는 사용자나 역할을 지정
- 정책 관리를 통해 리소스 접근을 세밀하게 제어할 수 있으며, 보안성을 강화

---

## 2. 대시보드(Horizon)

- 오픈스택의 공식 웹 기반 대시보드로, 사용자가 GUI를 통해 클라우드 리소스를 쉽게 관리하고 모니터링할 수 있도록 함

### 2.1 웹 기반 인터페이스

#### 주요 특징 및 기능

- 직관적인 사용자 인터페이스: 몇 번의 클릭만으로 가상 머신, 네트워크, 스토리지 볼륨 등의 리소스 생성 및 관리 가능
- 리소스 관리: 오픈스택의 전체 리소스를 관리할 수 있음
- 역할 기반 접근 제어: Horizon은 Keystone과 통합하여 역할 기반 접근 제어(RBAC)를 지원
- 실시간 모니터링 및 보고: 현재 상태와 성능 지표를 실시간으로 모니터링할 수 있는 기능 제공
- 플러그인 확장성: 추가 기능이나 사용자 정의 대시보드를 쉽게 통합할 수 있도록 지원
- 다국어 지원

### 2.2 사용자 경험 및 관리

#### 사용자 인터페이스 디자인

- 직관적인 디자인
- 네비게이션

#### 리소스 관리 및 모니터링

- 리소스 생성 및 관리
- 실시간 모니터링

#### 사용자 권한 및 접근 제어

- 역할 기반 접근 제어(RBAC)
- 사용자 및 프로젝트 관리

#### 사용성 향상을 위한 기능

- 플러그인 및 확장 기능
- 다국어 지원

### 2.3 대시보드 커스터마이징

#### 커스터마이징 가능한 요소

1. 테마 및 브랜딩: 테마를 조직의 브랜드와 일치시키기 위해 색상, 로고, 폰트 등을 커스터마이징할 수 있음
2. 네비게이션 및 메뉴 구성
3. 대시보드 위젯 및 패널 추가
4. 사용자 정의 페이지

#### 커스터마이징 방법

1. 테마 수정: CSS와 HTML 템플릿을 통해 할 수 있음
2. 패널 및 위젯 개발: Django 기반임으로 이를 토대로 개발하고 통합
3. 플러그인 활용

## 3. 컴퓨트 서비스(Nova)

- 오픈스택의 핵심 컴포넌트 중 하나로, 클라우드 컴퓨팅 환경에서 가상 머신의 생명 주기를 관리

### 3.1 아키텍처와 기능

#### 주요 구성 요소

1. Nova API 서버(nova-api): 사용자와 다른 오픈스택 서비스로부터의 API 요청을 받아 처리
2. Nova 스케줄러(nova-scheduler): VM 인스턴스를 생성할 적절한 컴퓨트 노드를 결정하는 역할
3. Nova 컴퓨트(nova-compute)
- 실제 컴퓨트 노드에서 실행되며, VM의 생명 주기 관리 작업을 수행
- 하이퍼바이저와 통신하여 VM의 생성, 실행, 중지 등을 관리
4. Nova Conductor(nova-conductor)
- 데이터베이스와 직접적인 통신을 처리하며, nova-compute 서비스와 데이터베이스 간의 중개자 역할
- 컴퓨트 노드와 데이터베이스 간의 직접적인 연결을 피하고, 보안성과 확장성을 향상시킴
5. 메시지 큐: Nova 컴포넌트 간의 비동기 통신을 위해 메시지 큐(RabbitMQ, AMQP 등)를 사용

#### 주요 기능

1. VM 인스턴스 관리: Nova는 VM 인스턴스의 생성, 삭제, 재시작, 마이그레이션 등의 작업 관리
2. 리소스 할당: Nova는 CPU, 메모리, 스토리지 등의 컴퓨터 리소스를 VM 인스턴스에 동적으로 할당 -> 클라두으 환경에서 리소스를 유연하게 관리할 수 있음
3. 네트워킹 통합: Nova는 Neutron(오픈스택의 네트워킹 서비스)과 통합되어, VM 인스턴스에 대한 복잡한 네트워킹 구성을 지원
4. 이미지 관리: Nova는 Glance(오픈스택의 이미지 서비스)와 통합되어, VM 생성 시 사용할 수 있는 디스크 이미지를 관리
5. 보안 그룹과 키 페어: VM의 보안을 관리하기 위해 보안 그룹(방화벽 규칙의 집합)과 키 페어(SSH 키) 제공

### 3.2 하이퍼바이저와 연동

#### 하이퍼바이저의 역할

- 리소스 분할: 물리적 하드웨어 리소스(CPU, 메모리, 스토리지 등)를 여러 VM 사이에서 분할하여 할당
- 격리: 각 VM은 독립적인 실행 환경을 갖게 되며, 다른 VM의 작업에 영향을 받지 않음
- 관리 및 제어: VM의 생성, 실행, 중지, 삭제 등을 관리하며, 네트워킹 및 스토리지 구성 등을 제어

#### Nova와 하이퍼바이저의 연동

1. 하이퍼바이저 선택 및 구성
- Nova에 사용할 하이퍼바이저를 선택하고 구성
- KVM, Xen, VMware vSphere, Micosoft Hyper-V 등 다양한 하이퍼바이저를 지원

2. 드라이버를 통한 통신
- Nova는 각 하이퍼바이저와 통신하기 위해 특정 드라이버를 사용
- 예를 들어, KVM 하이퍼바이저의 경우 Libvirt 드라이버를 사용하며, 이 드라이버는 Nova와 KVM 사이의 인터페이스 역할을 함

3. VM 생성 및 관리
- 사용자의 VM 생성 요청 -> Nova가 하이퍼바이저의 드라이버를 통해 해당 요청 전달 -> 하이퍼바이저가 물리적 리소스를 할당하고 VM을 실행
- 이후 Nova는 VM의 생명 주기(시작, 중지, 재시작, 삭제 등) 관리

4. 리소스 모니터링
- Nova는 하이퍼바이저를 통해 VM의 성능 지표와 리소스 사용량을 모니터링
- 이 정보는 리소스 할당 결정과 시스템 최적화에 사용될 수 있음

### 3.3 가상 머신 관리

#### VM 생성

- 이미지 선택: Glance에서 제공하는 OS 이미지 또는 사용자가 직접 제공한 이미지를 선택하는 것으로 시작
- 플레이버 선택: VM에 할당할 리소스의 양(CPU, 메모리, 스토리지 등)을 정의하는 플레이버 선택
- 네트워킹 설정: VM이 접속할 가상 네트워크 설정, Neutron을 통해 VM에 공개 IP 주소를 할당하거나 내부 네트워크에 연결할 수 있음
- 보안 그룹 설정: VM의 네트워크 트래픽을 제어하기 위한 보안 그룹을 설정, 특정 포트의 인바운드 및 아웃바운드 트래픽에 대한 규칙 설정
- 키 페어 할당: SSH 접속을 위한 키 페어를 VM에 할당, VM에 원격 접속 가능

#### VM 모니터링 및 관리

- 상태 모니터링: Nova는 VM의 현재 상태(활정, 중지, 오류 등)와 성능 지표(CPU 사용량, 메모리 사용량)를 모니터링, 이는 Horizon 대시보드나 CLI를 통해 확인 가능
- 스냅샷 생성
- 재시작 및 중지
- 크기 조정 및 마이그레이션: VM의 리소스를 증가시키거나 감소시키는 조정 작업 가능, VM을 다른 컴퓨트 노드로 마이그레이션 가능

#### VM 삭제

- 삭제하면 VM과 관련된 모든 리소스(디스크 볼륨, 네트워킹 설정 등)도 함께 제거

## 4. 이미지 서비스(Glance)

- 가상 머신 이미지의 등록, 저장, 검색 및 관리를 담당

### 4.1 이미지 관리의 개요

#### 주요 기능

1. 이미지 저장 및 관리: VM 이미지를 저장하고, 이미지에 대한 메타데이터를 관리
2. 이미지 형식 지원: RAW, VHD(Azure용), VMDK(VMware용), qcow2(KVM용), OVA 등이 포함
3. 이미지 공유 및 배포
4. 버전 관리 및 스냅샷
5. 보안: 이미지는 디스크에 암호화되어 저장 가능, SSL/TLS를 통해 안전하게 전송됨

#### 구성 요소

1. Glance API: 클라이언트 요청을 받아 처리하는 RESTful 인터페이스 제공
2. Glance Registry: 이미지 메타데이터를 저장하고 조회하는 서비스
3. 백엔드 스토리지: 로컬 파일 시스템, 오브젝트 스토리지(Swift), 블록 스토리지(Cinder) 등 다양하게 지원

### 4.2 기능과 구조

#### 주요 기능

1. 이미지 저장
2. 이미지 메타데이터 관리
3. 이미지 버전 관리 및 스냅샷
4. 이미지 공유 및 배포

#### 구조 및 구성 요소

1. Glance API(glance-api)
2. Glance Registry(glance-registry)
3. 백엔드 스토리지
4. 메타데이터 데이터베이스

### 4.3 이미지 저장 및 관리

#### 이미지 저장

1. 업로드: Glance API를 통해 진행
2. 스토리지 백엔드: 로컬 파일 시스템, 오브젝트 스토리지(Swift), 블록 스토리지(Cinder) 중 선택 가능
3. 암호화

#### 이미지 관리

1. 메타데이터 관리
2. 이미지 공유 및 접근 제어
3. 이미지 버전 관리 및 스냅샷
4. 이미지 삭제 및 정리

## 5. 블록 스토리지 서비스(Cinder)

- 오픈스택의 블록 스토리지 서비스로 가상 머신이나 기타 사용자에게 영구적인 블록 레벨 스토리지 제공

### 5.1 스토리지 아키텍처

#### 주요 구성 요소

1. Cinder API 서버(cinder-api): 사용자와 다른 오픈스택 서비스로부터의 API 요청을 받아 처리
2. Cinder 스케줄러(cinder-scheduler): 볼륨 생성 요청을 받았을 때 적절한 스토리지 백엔드를 결정
3. Cinder 볼륨 서비스(cinder-volume): 실제로 볼륨의 생성, 삭제, 연결, 분리 등을 담당
4. 메시지 큐: Cinder 컴포넌트 간의 비동기 통신을 위해 메시지 큐(RabbitMQ, AMQP 등)를 사용

#### 스토리지 아키텍처 특징

1. 다양한 스토리지 백엔드 지원
- 로컬 스토리지, iSCSI, Fibre, Channel, NFS 등 다양한 스토리지 프로토콜과 시스템 지원
- NetApp, Dell EMC, IBM Storage 등의 상용 스토리지 솔루션과의 통합도 지원

2. 스토리지 볼륨 관리: Cinder는 볼륨의 생명 주기를 관리, 사용자는 필요에 따라 볼륨을 생성, 크기 조정, 스냅샷 생성, 복제 등 작업
3. 멀티테넌시 지원: Cinder는 프로젝트 또는 사용자별로 볼륨을 격리하여 관리할 수 있음 -> 멀티테넌시 환경에서의 데이터 보안과 접근 제어를 강화
4. 고가용성 및 복원력: Cinder는 스토리지 백엔드의 장애에 대비하여 고가용성 제공
5. 확장성: Cinder의 모듈식 아키텍처는 클라우드 환경의 성장에 따라 쉽게 스토리지 용량을 확장할 수 있도록 함


### 5.2 볼륨 생성 및 관리

#### 볼륨 생성

1. 볼륨 생성 요청: Cinder API를 통해 새로운 볼륨 생성 요청 가능, 이 요청에는 크기, 타입, 위치 등의 정보를 포함할 수 있다.
2. 스토리지 백엔드 선택: Cinder 스케줄러는 사용자의 요청에 가장 적합한 스토리지 백엔드를 결정
3. 볼륨 생성: 선택된 스토리지 백엔드에 볼륨이 생성
4. 볼륨 정보 반환: 생성 완료 후, 볼륨 정보를 사용자에게 반환

#### 볼륨 관리

1. 볼륨 연결 및 분리: Nova를 통해 VM에 연결 가능하며, 연결하면 VM 내에서 추가 디스크 드라이브로 인식
2. 볼륨 크기 조정: 데이터 증가에 따라 볼륨의 용량을 확장하거나 축소할 수 있음
3. 스냅샷 및 복제
4. 볼륨 삭제
5. 볼륨 백업

### 5.3 고급 스토리지 기능

#### 스냅샷 관리

- 스냅샷 생성
- 스냅샷 기반 볼륨 생성

#### 볼륨 타입 및 QoS

- 볼륨 타입 생성
- 품질 보장(Quality of Service, QoS): 볼륨 타입에 QoS 규칙을 적용하여 IOPS(초당 입출력 연산 횟수)나 처리량(초당 전송 데이터량) 등의 성능 지표를 제한할 수 있음

#### 볼륨 마이그레이션

- 라이브 마이그레이션: 사용 중인 볼륨을 다른 스토리지 백엔드로 이동하는 라이브 마이그레이션을 지원

#### 볼륨 백업

- 볼륨 백업: 볼륨의 데이터를 백업하여 오브젝트 스토리지(Swift) 등의 다른 스토리지 시스템에 저장할 수 있는 기능 제공
- 증분 백업: 변경된 데이터만을 백업하는 증분 백업을 지원

#### 멀티 어태치

- 멀티 어태치: 하나의 볼륨을 여러 VM에 동시에 연결하는 기능, 사용 시 데이터 일관성과 동시성을 관리하기 위한 추가 메커니즘이 필요할 수 있음

## 6. 네트워킹 서비스(Neutron)

- 오픈스택의 네트워킹 서비스로, 가상 네트워크 인프라의 구성 및 관리를 담당

### 6.1 네트워킹 아키텍처

#### 주요 구성 요소

1. Neutron 서버(neutron-server): 핵심 컴포넌트, API 요청을 처리하고 네트워킹 구성을 관리
2. 플러그인 및 에이전트: 다양한 네트워킹 기술 지원을 위해 플러그인 아키텍처 사용
3. 메시지 큐: 분산된 아키텍처에서 비동기 메시징 지원
4. 데이터베이스: 네트워크 구성 및 상태 정보 저장을 위한 DB

#### 네트워킹 모델

1. 가상 네트워크: 가상 네트워크를 통해 VM, 컨테이너, 베어메탈 서버 간의 격리된 네트워킹 환경 구성 가능
2. 서브넷과 IP 주소 관리: 서브넷 생성 및 DHCP를 통해 VM에 IP 주소 자동 할당 가능
- [DHCP](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-DHCP-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80): 클라이언트에게 자동으로 IP를 할당하여 일정 기간 임대하는 프로토콜 
3. 라우터와 플로팅 IP: 가상 라우터를 통해 다른 네트워크 간의 트래픽 라우팅을 관리, 외부 네트워크와 통신을 위해 VM에 플로팅 IP 주소를 할당할 수도 있음
- 플로팅 IP: 가상머신이 인터넷과 외부망에 접근하기 위해 배정 받는 IP, IP를 자신이 원하는 가상머신에 할당, 취소, 재할당이 가능하기에 플로팅 IP이다.
4. 보안 그룹: VM 또는 네트워크 인터페이스에 적용할 수 있는 방화벽 규칙의 집합

### 6.2 네트워크 구성 및 관리

#### 가상 네트워크 생성

1. 가상 네트워크 생성: 가상 네트워크를 생성하여 독립적인 네트워크 영역 설정 가능
2. 서브넷 추가

#### 라우팅 및 외부 접속 설정

1. 라우터 생성 및 구성
2. 플로팅 IP 할당

#### 보안 설정

1. 보안 그룹 설정: 특정 네트워크 트래픽에 대한 접근 규칙을 정의(인바운드, 아웃바운드 트래픽)
2. 네트워크 정책 적용

#### 고급 네트워킹 기능

1. VLAN 및 VXLAN 지원
- VLAN: 가상 LAN으로 하나의 스위치에 여러 그룹을 나누는 기술
- VXLAN: 물리적인 네트워크보다 더 큰 스케일 지원, 가상화된 서버나 가상머신 간의 통신을 용이하게 해줌
2. 네트워크 토폴리지 시각화
- 네트워크 토폴리지: 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것

### 6.3 고급 네트워킹 기능

#### 1. 네트워크 가상화

- VXLAN(Virtual Extensible LAN): VXLAN 기술을 사용해 대규모 클라우드 환경에서 네트워크 오버레이를 구현
  - [오버레이 네트워크](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B2%84%EB%A0%88%EC%9D%B4_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC): 물리 네트워크 위에 성립되는 가상의 네트워크
- GRE(Generic Routing Encapsulation): GRE 터널링을 사용하여, 가상 네트워크 간에 격리된 통신 채널을 생성, GRE는 네트워크 확장성과 멀티테넌시를 지원
  - GRE: 데이터 패킷을 캡슐화하여 공용 네트워크를 통해 전송하는 프로토콜, 개별 네트워크 간의 연결을 단순화하기 위해 사용

#### 2. 로드 밸런싱

- LBaaS(Load Balancer as a Service): 로드 밸런서를 가상 서비스로 지원, 인바운드 트래픽을 여러 VM이나 서버에 분산시키는 기능 지원


#### 3. VPN(Virtual Private Network)

- VPNaaS(VPN as a Service): 사이트 간 VPN 연결을 설정하여 서로 다른 클라우드 환경 또는 데이터 센터 간에 안전한 통신 채널 구축 가능

#### 4. 방화벽 및 보안 그룹

- FWaaS(Firewall as a Service): 가상 방화벽을 서비스로 제공하여, 네트워크 트래픽의 필터링과 접근 제어를 구현. FWaaS를 통해 정교한 보안 정책 적용 가능
- 보안 그룹

#### 5. 네트워크 토폴로지 및 트래픽 모니터링

## 7. 오브젝트 스토리지 서비스(Swift)

- 오픈스택의 오브젝트 스토리지 시스템으로, 대규모의 비정형 데이터를 저장하기 위한 확장 가능한 스토리지 솔루션을 제공

### 7.1 스토리지 아키텍처와 원리

#### 주요 구성 요소

1. 프록시 서버(Swift Proxy Server): 클라이언트의 요청을 받아 처리하는 엔트리 포인트로, 오브젝트의 업로드, 다운로드, 삭제 등의 요청을 스토리지 노드로 라우팅 함
2. 스토리지 노드: 실제 데이터가 저장되는 물리적 또는 가상 서버
3. Ring: 
- Swift의 데이터 배치 알고리즘을 구현한 구조
- 오브젝트, 컨테이너, 계정 정보를 어떤 스토리지 노드에 저장할지 결정
- 데이터의 고른 분산과 빠른 검색을 위해 존재하며, 클러스터 내에서 노드의 추가 및 제거를 관리

#### 스토리지 아키텍처 원리

1. 데이터 분산과 복제: 오브젝트를 클러스터 내 여러 스토리지 노드에 분산 저장, 여러 복제본을 생성하여 다른 물리적 위치에 저장
2. 결함 내성과 자가 치유: 결함 내성(fault-tolerance)을 가지고 있어, 하드웨어 장애가 발생해도 시스템이 자동으로 복제본을 사용하여 데이터를 복구. 지속적인 무결성 검사와 동기화를 통해 데이터 일관성 유지
3. 확장성: 수평적 확장이 가능한 아키텍처를 가지고 있어, 스토리지 용량이나 처리량을 증가시키기 위해 노드를 추가하는 것은 간단함
4. RESTful API


### 7.2 오브젝트 스토리지 사용 사례

#### 1. 웹 및 모바일 애플리케이션의 정적 컨텐츠 호스팅

- 웹사이트나 모바일 애플리케이션의 이미지, 비디오, 스타일시트(CSS), 자바스크립트 파일 등과 같은 정적 컨텐츠를 저장하고 배포하는 데 이상적

#### 2. 대규모 데이터 아카이빙 및 백업

- 기업의 백업 데이터, 아카이브 문서, 로그 파일 등을 오랜 기간 동안 안전하게 보관해야 할 때 Swift 사용
- 데이터의 내구성과 가용성을 보장하며, 비용 효율적인 저장소 솔루션을 제공

#### 3. 미디어 콘텐츠 저장 및 스트리밍

- 비디오, 오디오, 이미지와 같은 대규모 미디어 파일을 저장하고 관리하는데 Swift를 활용할 수 있음
- 대용량 파일의 효율적인 저장과 빠른 접근 속도를 제공하여, 미디어 스트리밍 서비스의 백엔드로서 이상적

#### 4. 빅 데이터 및 분석

- 빅 데이터 앱에서 사용하는 대용량 데이터 세트를 저장하기 위한 확장 가능한 솔루션을 제공
- 데이터 분석 및 처리를 위해 Hadoop과 같은 분산 컴퓨팅 시스템과 통합될 수 있음

#### 5. 글로벌 콘텐츠 배포 네트워크(CDN)

- Swift와 CDN 기술을 통합하여, 전 세계 사용자에게 콘텐츠를 빠르게 제공 가능
- Swift 스토리지에 저장된 데이터는 CDN을 통해 캐싱되고, 사용자에게 가까운 위치에 제공
- CDN(Content Delivery Service): 전 세계에 분산된 서버 그룹을 통해 사용자에게 콘텐츠를 전송하는 기술

### 7.3 데이터 관리 및 보안

#### 데이터 관리

1. 데이터 복제: 모든 오브젝트를 클러스터 내 여러 위치에 복제본 생성
2. 컨테이너와 오브젝트: 저장된 오브젝트는 컨테이너 내에 조직화. 컨테이너는 오브젝트의 논리적인 그룹을 형성하고, 사용자는 컨테이너를 통해 데이터를 관리할 수 있음
3. 메타데이터 활용: 데이터 분류, 검색 및 관리를 용이하게 하는 메타데이터 추가 가능

#### 데이터 보안

1. 접근 제어: 오브젝트와 컨테이너에 대한 접근 권한 설정 가능
2. 암호화: 물리적으로 저장되는 스토리지 레벨에서 암호화. 데이터가 유출될 때 외부에 노출 방지
3. SSL/TLS 지원: 데이터 전송 시 보안을 위해 SSL/TLS를 통한 암호화 된 통신을 지원

#### 데이터 일관성

- Swift는 결국 일관성(Eventual Consistency) 모델을 사용
  - 이는 시스템 내의 모든 복제본이 최종적으로 동일한 상태에 도달하도록 보장
  - 하지만 복제 과정에서 일시적으로 데이터의 불일치가 발생할 수도 있음
- Swift는 지속적인 데이터 동기화와 무결성 검사를 통해 이러한 일관성을 관리

## 8. 오케스트레이션 서비스(Heat)

- 클라우드 인프라스트럭처의 자동화된 배포 및 관리를 가능하게 하는 오케스트레이션 도구

### 8.1 템플릿과 스택

#### 템플릿

- 인프라스트럭처의 구성 요소(가상 머신, 네트워크 볼륨 등)와 이들 사이의 관계, 필요한 속성 및 출력 등을 정의하는 파일
- Heat는 Heat Orchestration Template (HOT) 형식과 AWS CloudFormation 호환 형식을 지원
- YAML 형식으로 작성되며, 사용자가 인프라를 코드(IaC)로 정의할 수 있도록 지원

#### 스택

- 템플릿을 기반으로 생성된 리소스의 집합
- 사용자는 템플릿을 Heat에 제출하여 스택을 생성하며, Heat는 이 템플릿에 정의된 지시사항에 따라 리소스를 자동으로 배포
- 스택을 통해 사용자는 템플릿에 정의된 인프라스트럭처를 반복적이고 일관된 방식으로 배포 및 관리할 수 있음
- 필요에 따라 스택을 업데이트하거나 삭제할 수 있음

#### 예제: 간단한 웹 서버 배포 템플릿

```yaml
heat_template_version: 2013-05-23

description: >
  Heat template to deploy a single web server.

resources:
  my_instance:
    type: OS::Nova::Server
    properties:
      image: Ubuntu 18.04
      flavor: m1.small
      key_name: my_key
      networks:
        - network: private_network

my_floating_ip:
  type: OS::Neutron::FloatingIP
  properties:
    floating_network: public_network
    port_id: { get_resource: my_instance }
```

- 위 템플릿은 `my_instance` 라는 이름의 가상 머신 리소스와 `my_floating_ip` 라는 플로팅 IP 리소스를 정의함
- 가상 머신은 `Ubuntu 18.04` 이미지를 사용하고, `private_network` 에 연결됨
- 플로팅 IP는 `public_network` 에서 플로팅 IP를 할당받아 외부에서 접근 가능하도록 만듬
- 템플릿은 스택을 구성하는 '청사진', 스택은 청사진을 기반으로 실제 클라우드 환경에 배포된 인프라스트럭처의 '실체'

```shell
heat stack-create -f my_web_server_template.yaml -P "key_name=my_key;network=private_network" my_web_server_stack
```

- 위 명령어로 템플릿을 사용해 스택을 생성할 수 있음
- `-f` 키워드로 사용할 템플릿 파일을 지정하고, `-P` 키워드로 템플릿 내에서 필요한 파라미터를 전달

### 8.2 자동화와 스케일링

#### 자동화

- Heat의 자동화 기능은 템플릿을 기반으로 인프라스트럭처를 일관되고 반복 가능한 방식으로 배포 가능케 함
- 이는 다음과 같은 장점을 가짐
  - 속도와 정확성: 배포 속도 크게 향상, 인간의 실수로 인한 오류 최소화
  - 배포의 일관성: 동일한 템플릿을 사용하여 여러 환경에 동일한 인프라 배포 가능
  - 복잡한 인프라스트럭처의 간소화: 복잡한 인프라스트럭처 설정 관리의 복잡성을 줄임

#### 스케일링

- 애플리케이션의 부하 변화에 따라 리소스(예를 들어 가상 머신 인스턴스)를 자동으로 확장하거나 축소할 수 있음
- 이는 다음과 같은 장점을 가짐
  - 스케일링 정책 정의
  - 자동 리소스 조정
  - 고가용성 및 비용 효율성

#### 예제: 자동 스케일링 템플릿

```yaml
heat_template_version: 2013-05-23

description: Auto-scaling web application

resources:
  web_server_group:
    type: OS::Heat::AutoScalingGroup
    properties:
      ... # AutoScalingGroup properties

  scale_up_policy:
    type: OS::Heat::ScalingPolicy
    properties:
      adjustment_type: change_in_capacity
      auto_scaling_group_id: {get_resource: web_server_group}
      cooldown: 60
      scaling_adjustment: 1

  cpu_alarm_high:
    type: OS::Ceilometer::Alarm
    properties:
      comparison_operator: gt
      statistic: avg
      threshold: 50
      alarm_actions: [{get_attr: [scale_up_policy, alarm_url]}]
      ...
```

- 위 템플릿은 CPU 사용률이 50%를 초과하면 웹 서버 그룹에 서버 인스턴스를 자동으로 하나 추가하는 스케일링 정책을 정의함

### 8.3 고급 기능과 사용 사례

#### 고급 기능

1. 조건부 리소스 생성: Heat 템플릿은 조건문을 지원
2. 소프트웨어 구성 및 배포: Heat는 소프트웨어 구성 요소의 설치 및 구성을 자동화하는 기능을 제공
3. 중첩 스택(Nested Stacks): 복잡한 인프라스트럭처를 모듈화하고 재사용할 수 있도록, 하나의 Heat 템플릿 내에서 다른 Heat 템플릿(중첩 스택)을 참조할 수 있음

#### 사용 사례

1. 다층 애플리케이션 배포: 웹 애플리케이션, 데이터베이스 서버, 로드 밸런서 등 다양한 계층으로 구성된 애플리케이션의 전체 스택을 하나의 Heat 템플릿으로 정의하고 배포할 수 있음
2. 오토 스케일링 환경 구성: 애플리케이션의 트래픽이 증가할 경우 자동으로 추가 인스턴스를 배포하여 처리 능력을 확장하고, 트래픽이 감소할 경우 자동으로 인스턴스를 줄여 리소스를 효율적으로 사용할 수 있는 오토 스케일링 환경을 구성함
3. 재해 복구 전략 구현: 복수의 지역에 걸쳐 동일한 인프라스트럭처를 배포하고, 주요 지역에 장애가 생기면 자동으로 트래픽을 백업 지역으로 전환하여 서비스의 가용성을 유지

## 9. 기타 컴포넌트(Barbican, Ceilometer, Ironic, StackLight)

1. Barbican: 보안 키 및 인증 정보의 안전한 저장 및 관리를 담당하는 서비스
2. Ceilometer: 오픈스택 환경에서의 사용량 데이터 수집 및 알림 기능을 제공
3. Ironic: 베어메탈 서비스로, 물리적 서버를 관리하고 프로비저닝하는 데 사용
4. StackLight: Mirantis의 솔루션 중 하나로, 오픈스택 환경의 모니터링 및 로깅을 제공

### 9.1 보안 관리(Barbican)

#### 주요 기능

- 비밀 관리: 비밀번호, OAuth 토큰, SSL/TLS 인증서, 암호화 키 등의 비밀을 저장하고 액세스 제어를 관리
- 암호화 키 관리: 대칭 및 비대칭 암호화 키를 생성, 저장 및 관리 기능 제공. 이는 데이터를 암호화하거나 디지털 서명을 생성할 때 필요한 기능
- REST API: 다른 오픈스택 서비스나 사용자 정의 애플리케이션에서 쉽게 비밀과 키를 관리할 수 있음
- 플러그인 아키텍처: 다양한 백엔드 저장소(예. 하드웨어 보안 모듈(HSM), 키 관리 시스템 등)와 통합을 지원하는 플러그인 아키텍처를 갖추고 있음

#### 사용 예시

1. 인증서 관리: 웹 서버를 위한 SSL/TLS 인증서를 안전하게 저장하고, 인증서 갱신 시기를 관리
2. 데이터 암호화: 데이터베이스에 저장된 민감한 정보를 암호화하기 위한 암호화 키를 생성 및 관리
3. 애플리케이션 비밀 관리: API 키나 비밀번호 같은 애플리케이션 비밀을 애플리케이션 구성 파일에 저장하지 않고, Barbican에 저장

#### 구성 요소

- Barbican API 서버: 클라이언트 요청 처리, 비밀 및 키 관리 작업 실행
- 비밀 저장소: 비밀과 키를 저장하는 데이터베이스 또는 다른 형태의 저장소
- 키 관리 시스템(KMS) 및 하드웨어 보안 모듈(HSM): 고급 보안 요구사항을 충족하기 위해 선택적으로 통합할 수 있는 외부 시스템

### 9.2 미터링 빌링(Ceilometer)

- 클라우드 미터링: 클라우드 서비스의 사용량을 측정하고, 요금을 산정하는 과정

#### 주요 구성 요소

- Agent: 데이터 수집 담당 요소. 다양한 에이전트가 네트워크, 컴퓨트, 스토리지 등의 리소스 사용 정보를 수집
- Collector: 에이전트로부터 데이터를 수집하고 처리하는 서비스
- Datastore: 수집된 데이터를 저장하는 데이터베이스
- API 서버: 사용자 및 애플리케이션의 데이터 쿼리 요청을 처리하고, 수집된 데이터에 대한 액세스를 제공

#### Ceilometer 사용 예제

- Ceilometer 설치 및 설정: Ceilometer는 오픈스택 설치 시 함꼐 설치되거나 필요에 따라 별도로 추가할 수 있음. 설치 후, Ceilometer 서비스를 구성하고 필요한 에이전트를 배포해야 함
- 리소스 사용량 측정: 컴퓨터 인스턴스, 볼륨 사용량, 네트워크 트래픽 등 다양한 리소스이 사용량을 측정할 수 있음
- 사용량 데이터 조회: Ceilometer API를 사용하여 수집된 데이터를 조회할 수 있음
  - `ceilomter sample-list -m cpu_util -q resource=<instanceID>` 와 같은 명령어로 지정된 인스턴스의 CPU 사용률을 확인할 수 있다.
- 알림 및 경보 생성

### 9.3 베어 메탈(Ironic)

#### 주요 기능

- 베어 메탈 노드 프로비저닝: 네트워크 기반의 부팅 방식(PXE boot)을 사용하여 베어 메탈 서버에 OS 이미지를 설치
- 노드 상태 관리: 서버의 전원 관리와 같은 기본적인 하드웨어 관리 기능을 제공
- 다중 테넌트 지원: 오픈스택의 다중 테넌트 환경에서 베어 메탈 서버를 안전하게 분리하여 제공. 이를 통해 서로 다른 사용자나 프로젝트가 동일한 물리적 인프라 상에서 자신들만의 서버를 사용할 수 있음
- 하드웨어 검사: 서버의 하드웨어 사양(예. CPU, 메모리, 디스트)을 자동으로 검사하고 인벤토리 정보를 수집

#### 구성 요소

- Ironic API 서버: 프로비저닝 및 관리 작업을 수행하는 인터페이스 제공
- Conductor: 실제 베어 메탈 노드와 상호작용하여 프로비저닝 작업을 수행하는 구성 요소. 하드웨어와 통신, 작업 실행, 상태 관리 등을 담당
- Database: 노드의 상태, 구성, 프로비저닝 정보 등을 저장하는 데이터베이스

#### 활용 사례

- 고성능 컴퓨팅(High-Performance Computing, HPC): 가상화 오버헤드없이 전체 하드웨어 리소스를 활용할 수 있어, 고성능이 요구되는 HPC 환경에 적합
- 데이터 센터 운영: 다양한 하드웨어를 효율적으로 관리하고, 필요에 따라 빠르게 서버를 프로비저닝할 수 있다.
- 네트워크 기능 가상화(Network Functions Virtualization, NFV): 네트워크 기능을 소프트웨어로 구현할 떄, 베어 메탈 서버에서 직접 실행하여 성능을 최적화할 수 있음

### 9.4 모니터링(StackLight)

#### 구성 요소

1. 센서(Sensors)
- 시스템 및 서비스에서 발생하는 메트릭과 로그를 수집하는 역할
- 오픈스택 내부의 각종 서비스(Nova, Neutron, Cinder 등)와 인프라스트럭처(서버, 네트워크 장비 등)로부터 세부적인 운영 데이터를 취함

2. 분석기(Analyzers)
- 수집된 데이터를 처리하고 분석하여, 시스템의 상태와 성능, 잠재적 문제 등을 식별
- Prometheus가 메트릭에 대한 분석을 담당한다면, Elasticsearch는 로그 데이터의 분석을 맡아 처리 속도와 효율성을 높임

3. 대시보드(Dashboards)
- 분석된 데이터를 시각적으로 표현
- Grafana가 대표적 예시

4. API
- 시스템 외부에서 StackLight의 기능을 조작하거나 조회할 수 있도록 기능 제공

5. 알림 매니저(Notification Managers)
- 시스템의 임계값을 초과하는 이벤트나 예외 상황을 감지했을 때, 사전에 정의된 알림 규칙에 따라 사용자에게 경고
- 경고 관리, 다양한 채널(이메일, SNS, 웹훅 등)을 통한 알림

#### 추가 구성 요소

- 로그 수집기(Log Collectors): Logstash는 로그 수집기로서 로그 데이터를 수집, 변환, 전송하는 역할
- 저장소(Storage): Elasticsearch는 로그와 메트릭 데이터의 저장소 역할도 수행. 분석할 준비가 된 데이터를 효과적으로 저장하고, 빠른 검색, 질의 응답을 지원
